package io.singularitynet.sdk.daemon;

import io.grpc.*;
import java.math.BigInteger;
import java.net.URL;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Function;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.singularitynet.sdk.ethereum.Ethereum;

// @ThreadSafe
public class BaseDaemonConnection implements DaemonConnection {

    private final static Logger log = LoggerFactory.getLogger(BaseDaemonConnection.class);

    private final EndpointSelector endpointSelector;
    private final ClientInterceptorProxy interceptorProxy;
    private final Ethereum ethereum;

    private AtomicReference<ManagedChannel> channel = new AtomicReference<>();
    private volatile Endpoint endpoint;

    public BaseDaemonConnection(EndpointSelector endpointSelector,
            Ethereum ethereum) {
        log.info("New daemon connection, endpointSelector: {}", endpointSelector);
        this.endpointSelector = endpointSelector;
        this.ethereum = ethereum;
        this.interceptorProxy = new ClientInterceptorProxy();
    }

    @Override
    public <T> T getGrpcStub(Function<Channel, T> constructor) {
        return constructor.apply(getChannelLazy());
    }

    @Override
    public void setClientCallsInterceptor(ClientInterceptor interceptor) {
        interceptorProxy.setDelegate(interceptor);
    }

    @Override
    public Endpoint getEndpoint() {
        return endpoint;
    }

    @Override
    public BigInteger getLastEthereumBlockNumber() {
        return ethereum.getEthBlockNumber();
    }

    @Override
    public void shutdownNow() {
        channel.get().shutdownNow();
        log.info("gRPC channel to daemon closed");
    }

    private ManagedChannel getChannelLazy() {
        ManagedChannel value = channel.get();
        if (value != null) {
            return value;
        }

        value = getChannel();
        if (channel.compareAndSet(null, value)) {
            return value;
        }
        return channel.get();
    }
    
    // TODO: make this part of the configuration
    private static int MAX_GRPC_INBOUND_MESSAGE_SIZE = 40 * (1 << 20);

    private ManagedChannel getChannel() {
        endpoint = endpointSelector.nextEndpoint();
        URL url = endpoint.getUrl();
        ManagedChannelBuilder builder = ManagedChannelBuilder
            .forAddress(url.getHost(), url.getPort())
            .maxInboundMessageSize(MAX_GRPC_INBOUND_MESSAGE_SIZE)
            .intercept(interceptorProxy);
        // TODO: test HTTPS connections
        if ("http".equals(url.getProtocol())) {
            builder.usePlaintext();
        }
        ManagedChannel channel = builder.build();
        log.info("gRPC channel created, channel: {}", channel);
        return channel;
    }

    // @ThreadSafe
    private static class ClientInterceptorProxy implements ClientInterceptor {

        private final static Logger log = LoggerFactory.getLogger(ClientInterceptorProxy.class);

        private volatile ClientInterceptor delegate;

        public void setDelegate(ClientInterceptor delegate) {
            this.delegate = delegate;
        }

        private static final String PAYMENT_CHANNEL_STATE_SERVICE = "escrow.PaymentChannelStateService";
        private static final String FREE_CALL_STATE_SERVICE = "escrow.FreeCallStateService";
        private static final String PROVIDER_CONTROL_SERVICE = "escrow.ProviderControlService";

        @Override
        public <ReqT,RespT> ClientCall<ReqT,RespT> interceptCall(
                MethodDescriptor<ReqT,RespT> method,
                CallOptions callOptions,
                Channel next) {

            if (PAYMENT_CHANNEL_STATE_SERVICE.equals(getServiceName(method))) {
                log.debug("Skip processing for PaymentChannelStateService call");
                return next.newCall(method, callOptions);
            }

            if (FREE_CALL_STATE_SERVICE.equals(getServiceName(method))) {
                log.debug("Skip processing for FreeCallStateService call");
                return next.newCall(method, callOptions);
            }

            if (PROVIDER_CONTROL_SERVICE.equals(getServiceName(method))) {
                log.debug("Skip processing for ProviderControlService call");
                return next.newCall(method, callOptions);
            }

            log.debug("New gRPC call intercepted, method: {}, callOptions: {}, gRPC channel: {}", method, callOptions, next);
            return delegate.interceptCall(method, callOptions, next);
        }

    }

    private static String getServiceName(MethodDescriptor<?, ?> method) {
        return MethodDescriptor.extractFullServiceName(method.getFullMethodName());
    }

}
